package java01_base;

import javax.sql.RowSet;
/* -----------------------------------------------------------------------------------------------------------------------------------------
 * 变量		
 * 		内存中临时开辟一个空间存值，定义之后，该区域有自己的名称（变量名）和类型（数据类型）；用来不断存放同一类型的常量，并可以重复使用；
 * 			基本类型（primitive type）	  引用类型（reference type）		枚举类型（enumeration type）
 * 
 *		1.引用数据类型：
 * 			类(String也是类)、接口、数组
 * 
 *		2.基本数据类型(8种)：
 * 			四个整型		[byte(1个字节),short(2个字节),int(4个字节),long(8个字节)]				整型就用int;		除了byte用来做数组用的多，
 * 			两个浮点型	[float(4个字节),double(8个字节)]										浮点型就用double
 * 			字符型		[char](2个字节)  char的范围0-65535；									正好一个中文是两个字节。
 *			布尔型		[boolean](1个字节)
 *
 *			了解java虚拟机的底层会知道
				float在内存中是当作double来处理的
				byte、short、char、boolean在内存中都以int形式处理的；
			如果用其他，不但不节约内存资源，虚拟机为校验float、short等的精度，会花费更多的系统资源。
 *				其实这些资源的开销对于整个应用程序和现有硬件资源而言就是九牛一毛，微乎其微，没必要过于在意。就用习惯的形式即可。
 *				不要自作聪明的用特别的数据类型，浮点就double，整形就int，长整型就long，其它的必要性都不大(byte的话，用来做数组还是很方便的，除此不推荐使用)；
 * 
 * 		 3.数据类型转换
 * 			自动提升（小转大）:	
 * 				byte b;	
 * 				int i;	
 * 				i = i + b;		byte运算中自动提升转换为int;
 * 			强制转换（大转小）:	
 * 				b = (byte)(b + 1);				1是int，比byte大，赋给byte要强制转；
 * 				float f = 3.4 					这种写法是错的，3.4默认双精度，赋给float会造成精度损失，需强转。float f =(float)3.4 或float f =3.4F;
 * 				short s1 = 1; s1 += 1;			+=隐含有强制转换类型
 * -----------------------------------------------------------------------------------------------------------------------------------------
 */
public class C2_变量 {
	public static void main(String[] args) {	
		
		// 八种基础类型变量的默认值
		byte  b = 0;			// 数组用; 用来做数组还是很方便的，除此不推荐使用
		short s = 0;			// 少用；
		int   a = 0;			// 整型都用int；
		long  l = 0L;   		// 长整型用long。虽然long类型也会增加资源的开销，但是毕竟能完成int完成不了的功能。
		
		double d = 0.0;			// 浮点型都用double
		float  f = 0.0f;		// 注意后面接f，因为2.3默认是double类型，必须强转；f是强转的意思；

		char 	ch = '\u0000';	// 单个字符;		字符型（char）的基本类型变量的默认为"/u0000"(null)
		boolean bl = false;
		
		// 引用数据类型默认为null		
		String str	= null;		// String是个final类，不能被继承；
		RowSet rs	= null;		
		
		// 数据类型转换
		bl = (int)-45.89f == -45;	// 转换过程中可能导致溢出或损失精度
	}
}
