package java03_oop;
/*	
 * 抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。
 * Java 支持创建只暴漏接口而不包含方法实现的抽象的类
 * 这种抽象技术的主要目的是把类的行为和实现细节分离开
 * 
 * 钟哥总结：
 * 		子类继承抽象类，必须重写所有的抽象方法；不然子类依旧是抽象类；
 * 		抽象类里面可以有非抽象方法；
 * 		
 * 		抽象
 * 			功能定义完了，功能体如何实现，我不确定；
 * 			强制子类去完成某些功能，因为子类必须重写它的方法；
 * 
 * 			子类在不断向上抽取的过程中，发现，功能声明一致，但是功能实现不一致；
 * 			这时候就将声明向上抽取，形成抽象方法；
 * 
 * 			而抽象方法要定义在抽象类里面；
 * 			抽象类不能用new进行实例化；就是不能创建对象；
 *			想要创建对象，必须通过子类复写父类中所有的抽象方法后,该子类才可以创建对象；
 *
 *			注意，抽象类里面可以没有抽象方法，但是有抽象方法一定是抽象类；
 *
 *		接口
 *			简单的理解成抽象类的特殊表现形式；当抽象类中的各方法全都是抽象方法，那么就用接口来表示；
 *			除了抽象类，普通类实现接口，必须实现接口里的所有方法；抽象类可以不实现，让其子类实现；
 *			特点：
 *				接口是对外暴露的规则；
 *				接口是功能的扩展；
 *				接口的出现减低了耦合性；
 *				在java中多继承的机制被java通过另一种形式来体现，就是多实现；
 *			接口中的成员是共有的；
 *
 *			接口中通常定义的内容：
 *				1.	全局常量：public static final；接口中定义的成员变量实际上都是常量
 *				2.	共有的抽象方法：public abstract
 *			
 *			实例：主板的pci接口。插座。笔记本的usb接口；
 *			JDBC接口，各个数据库厂商去实现它
 *
 *			接口必须要具体类实现才有意义，所以必须是public类。
 *			接口中的方法不管有没有加public修饰，都是public，实现它的时候也必须要是public
 *			
 **/

public class C02_继承_抽象和接口 {
	public static void main(String[] args) {
		String str = "可以进入String类，它继承了Serializable、Comparable等很多接口；要实现它们的所有方法";
	}
}

abstract class AbsDemo{				//	1.	抽象类不能被new对象；因为方法体都没有怎么用？
	abstract void show();			//	2.	抽象方法所在类一定得是抽象类；
	abstract void show1();			//		没有大括号
	void show2(){					//	3.	抽象类里面可以有非抽象方法；这个子类就不需要一定重写；
		
	}
}

class subDemo extends AbsDemo{
	void show(){					//	4.	子类必须覆盖所有的抽象方法，不然子类也还是抽象类；
		System.out.println("重写");
	}
	void show1(){
		
	}
}
	
//public interface Xxx {
//	public void testXxx();
//}


